
% Actions Definitions: Internal
act
	% Weather polling
	SendWeatherPoll;
	RecvWeatherPoll;
	WeatherPoll;
	SendBadWeather: Bool;
	RecvBadWeather: Bool;
	BadWeather: Bool;

	% EV polling
	SendEVPoll: Nat;
	RecvEVPoll: Nat;
	EVPoll: Nat;
	SendEVDetected: Nat # Bool;
	RecvEVDetected: Nat # Bool;
	EVDetected: Nat # Bool;

	% Light timeouts
	SendRequestGreen: Nat;
	RecvRequestGreen: Nat;
	RequestGreen: Nat;
	SendCycleDone;
	RecvCycleDone;
	CycleDone;

% Actions Definitions: External 
act 
	ShowLight: Nat # LightColorState;
	LightTimeout: Nat # LightColorState;
	EVApproaching: Nat;
	EVPassed: Nat;
	EVPresent: Nat; 		% Observation Variable or State
	Weather: WeatherCondition;
	UserApproaching: Nat;
	UserPassed: Nat;
	UsersDetected: Nat # Bool;

% Constants
map
 	TRAFFIC_LIGHT_COUNT: Nat;
eqn
	% TRAFFIC_LIGHT_COUNT = 16;
	TRAFFIC_LIGHT_COUNT = 6;

% Data Types Definitions: 
sort 	
	LightColorState = struct Green | Orange | Red;
	WeatherCondition = struct Dry | Snowing | Raining;

sort
	UserPresence = List(Bool);
map
	setUserPresence': UserPresence # Nat # Nat # Bool -> UserPresence;
	setUserPresence: UserPresence # Nat # Bool -> UserPresence;
	defaultUserPresence: UserPresence;
var
	up: UserPresence;
	i: Nat;
	t: Nat;
	c: Nat;
	b: Bool;
eqn
	setUserPresence'([], i, t, b) = [];
	i == t -> setUserPresence'(up, i, t, b) = b |> setUserPresence'(tail(up), i + 1, t, b);
	i != t -> setUserPresence'(up, i, t, b) = head(up) |> setUserPresence'(tail(up), i + 1, t, b);

	% Mappings
	setUserPresence(up, t, b) = setUserPresence'(up, 0, t, b);
	defaultUserPresence = [false, false];

% Traffic lights
sort
	TrafficLightStates = List(LightColorState);
map
	setTrafficLightState': TrafficLightStates # Nat # Nat # LightColorState -> TrafficLightStates;

	% Mappings
	setTrafficLightState: TrafficLightStates # Nat # LightColorState -> TrafficLightStates;
	defaultLights: TrafficLightStates;

	setEVPresentHelper: List(Bool) # Nat # Nat # Bool -> List(Bool);
	setEVPresent: List(Bool) # Nat # Bool -> List(Bool);
	defaultEVPresent: List(Bool);

var
	ts: TrafficLightStates;
	evs: List(Bool);
	i: Nat;
	t: Nat;
	c: LightColorState;
	b: Bool;
eqn
	setTrafficLightState'([], i, t, c) = [];
	i == t -> setTrafficLightState'(ts, i, t, c) = c |> setTrafficLightState'(tail(ts), i + 1, t, c);
	i != t -> setTrafficLightState'(ts, i, t, c) = head(ts) |> setTrafficLightState'(tail(ts), i + 1, t, c);

	setEVPresentHelper([], i, t, b) = [];
	i == t -> setEVPresentHelper(evs, i, t, b) = b |> setEVPresentHelper(tail(evs), i + 1, t, b);
	i != t -> setEVPresentHelper(evs, i, t, b) = head(evs) |> setEVPresentHelper(tail(evs), i + 1, t, b);

	% Mappings
	setTrafficLightState(ts, t, c) = setTrafficLightState'(ts, 0, t, c);
	defaultLights = [Red,Red,Red,Red,Red,Red];
	defaultEVPresent = [false, false,false, false,false, false];
	setEVPresent(evs, t, b) = setEVPresentHelper(evs, 0, t, b);

% Process: 
proc 
	LightComponent(lights: TrafficLightStates) =
		sum t: Nat. (t < TRAFFIC_LIGHT_COUNT) -> (
			(lights . t == Red) -> 
				RecvRequestGreen(t) .
				sum ree: Nat. (ree < TRAFFIC_LIGHT_COUNT) -> (
					(ree == t) -> ShowLight(ree, Green) +
					(ree != t) -> ShowLight(ree, Red)
				) .
				LightComponent(setTrafficLightState(defaultLights, t, Green))
			+
			(lights . t == Green) ->
				LightTimeout(t, Green) .
				ShowLight(t, Orange) .
				LightComponent(setTrafficLightState(lights, t, Orange))
			+
			(lights . t == Orange) ->
				LightTimeout(t, Orange) .
				ShowLight(t, Red) .
				SendCycleDone .
				LightComponent(setTrafficLightState(lights, t, Red))
		)
	;
	EVComponent(lights: TrafficLightStates, evPresent: List(Bool)) =
		sum t: Nat. (t < TRAFFIC_LIGHT_COUNT) -> ((
			EVApproaching(t) .
			EVComponent(setTrafficLightState(lights, t, Green), setEVPresent(evPresent, t, true))
		) + (
			EVPassed(t) .
			EVComponent(setTrafficLightState(lights, t, Red), setEVPresent(evPresent, t, false))
		) + (
			RecvEVPoll(t) .
			SendEVDetected(t, lights . t == Green) .
			EVComponent(lights, evPresent)
		) + (
			(evPresent . t == true) -> 
			EVPresent(t) .
			EVComponent(lights, evPresent)
		))
	;
	WeatherComponent(current: WeatherCondition) =
		sum new: WeatherCondition .
			Weather(new) .
			WeatherComponent(new)
		+
			RecvWeatherPoll .
			(
				(current == Dry) -> SendBadWeather(false) +
				(current != Dry) -> SendBadWeather(true)
			) .
			WeatherComponent(current)
	;

	RestartCycle(users: UserPresence) =
		RecvCycleDone .
		EVChecking(0, users)
	;

	EVChecking(t: Nat, users: UserPresence) =
		(t == TRAFFIC_LIGHT_COUNT) ->
			%BadWeatherChecking(0, users) <>
			RestartCycle(users) <>
			SendEVPoll(t) .
			((
				RecvEVDetected(t, true) .
				SendRequestGreen(t) .
				% BadWeatherChecking(0)
				% Once we give someone a green light, restart the cycle
				RestartCycle(users)
			) + (
				RecvEVDetected(t, false) .
				EVChecking(t + 1, users)
			)) +
		sum u: Nat. (u < TRAFFIC_LIGHT_COUNT) -> (
			UserApproaching(u) .
			EVChecking(t, setUserPresence(users, u, true)) +
			UserPassed(u) .
			EVChecking(t, setUserPresence(users, u, false))
		)
	;
	
	BadWeatherChecking(t: Nat, users: UserPresence) =
		(t == TRAFFIC_LIGHT_COUNT) ->
			RegularChecking(0, users) <>
			((
				(users . t == true) ->
				UsersDetected(t, true) .
				SendWeatherPoll .
				RecvBadWeather(true) .
				SendRequestGreen(t) .
				% Once we give someone a green light, restart the cycle
				RestartCycle(users)
			) + (
				(users . t == false) ->
				UsersDetected(t, false) .
				BadWeatherChecking(t + 1, users)
			)) +
		sum u: Nat. (u < TRAFFIC_LIGHT_COUNT) -> (
			UserApproaching(u) .
			BadWeatherChecking(t, setUserPresence(users, u, true)) +
			UserPassed(u) .
			BadWeatherChecking(t, setUserPresence(users, u, false))
		)
	;

	RegularChecking(t: Nat, users: UserPresence) =
		((t == TRAFFIC_LIGHT_COUNT) ->
			RestartCycle(users) <>
			((
				(users . t == true) ->
				UsersDetected(t, true) .
				SendRequestGreen(t) .
				RestartCycle(users)
			) + (
				(users . t == false) ->
				UsersDetected(t, false) .
				RegularChecking(t + 1, users)
			)) +
		sum u: Nat. (u < TRAFFIC_LIGHT_COUNT) -> (
			UserApproaching(u) .
			RegularChecking(t, setUserPresence(users, u, true)) +
			UserPassed(u) .
			RegularChecking(t, setUserPresence(users, u, false))
		))
	;

% init WeatherComponent(Dry);
init
hide(
	{
		SendWeatherPoll,
		RecvWeatherPoll,
		WeatherPoll,
		SendBadWeather,
		RecvBadWeather,
		BadWeather,
		SendEVPoll,
		RecvEVPoll,
		EVPoll,
		SendEVDetected,
		RecvEVDetected,
		EVDetected,
		SendRequestGreen,
		RecvRequestGreen,
		RequestGreen,
		SendCycleDone,
		RecvCycleDone,
		CycleDone,
		EVPresent
	},
allow(
	{
		ShowLight,
		LightTimeout,
		EVApproaching,
		EVPassed,
		Weather,
		UserApproaching,
		UserPassed,
		UsersDetected
	},
comm(	{
		SendWeatherPoll|RecvWeatherPoll -> WeatherPoll,
		SendBadWeather|RecvBadWeather -> BadWeather,

		SendEVPoll|RecvEVPoll -> EVPoll,
		SendEVDetected|RecvEVDetected -> EVDetected,

		SendRequestGreen|RecvRequestGreen -> RequestGreen,
		SendCycleDone|RecvCycleDone -> CycleDone
	},
	EVChecking(0, defaultUserPresence) || 
	WeatherComponent(Dry) || 
	LightComponent(defaultLights) || 
	EVComponent(defaultLights, defaultEVPresent)
)));
%));
