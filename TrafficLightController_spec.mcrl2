% Data Types Definitions: 
sort 	
	LightColorState = struct green | orange | red;
	WeatherCondition = struct dry | snowing | raining;
	Array = Nat -> Bool;

map set: Array # Nat -> Array;
    clear: Array # Nat -> Array;
 	trafficLightAmount:Nat;

var a: Array;
    n: Nat;

eqn set(a, n) = a[n -> true];
    clear(a, n) = a[n -> false];
 	trafficLightAmount = 3;

% Actions Definitions: External 
act 
	ShowLight: Nat # LightColorState;
	LightTimeout: Nat # LightColorState;
	UserDetected: Nat # Bool;
	EV_Approaching: Nat;
	EV_Passed: Nat;
	Weather: WeatherCondition;

% Actions Definitions: Internal
act 
	WeatherPoll;
	EV_Poll: Nat;
	CycleDone: Nat;
	BadWeather: Bool;
	RequestGreen: Nat;
	EV_Detected: Nat # Bool;

% REQUIRED FOR PARSING CHECK! NOT ACTUAL LOGIC YET
proc 
	EV_Component(EV_Booleans: Array) = 
		sum t:Nat. (t < trafficLightAmount) ->
			EV_Approaching(t).
			EV_Component(set(EV_Booleans, t))
		+
		sum t:Nat. (t < trafficLightAmount) ->
			EV_Passed(t).
			EV_Component(clear(EV_Booleans, t))
		+
		sum t:Nat. (t < trafficLightAmount) ->
			EV_Poll(t).
			EV_Detected(t,EV_Booleans(t)).
			EV_Component(EV_Booleans)
;

% Map every number to false at first:
init EV_Component(lambda f: Nat . false);