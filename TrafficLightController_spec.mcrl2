
% Actions Definitions: Internal
act
	% Weather polling
	SendWeatherPoll;
	RecvWeatherPoll;
	WeatherPoll;
	SendBadWeather: Bool;
	RecvBadWeather: Bool;
	BadWeather: Bool;

	% EV polling
	SendEVPoll: Nat;
	RecvEVPoll: Nat;
	EVPoll: Nat;
	SendEVDetected: Nat # Bool;
	RecvEVDetected: Nat # Bool;
	EVDetected: Nat # Bool;

	% Light timeouts
	SendRequestGreen: Nat;
	RecvRequestGreen: Nat;
	RequestGreen: Nat;
	SendCycleDone;
	RecvCycleDone;
	CycleDone;

	% Users
	SendUsersPoll: Nat;
	RecvUsersPoll: Nat;
	UsersPoll: Nat;
	SendUsersDetected: Nat # Bool;
	RecvUsersDetected: Nat # Bool;
	UsersDetected: Nat # Bool;

% Actions Definitions: External 
act 
	ShowLight: Nat # LightColorState;
	LightTimeout: Nat # LightColorState;
	EVApproaching: Nat;
	EVPassed: Nat;
	Weather: WeatherCondition;
	UserApproaching: Nat;
	UserPassed: Nat;


% Constants
map
 	TRAFFIC_LIGHT_COUNT: Nat;
eqn
	% TRAFFIC_LIGHT_COUNT = 16;
	TRAFFIC_LIGHT_COUNT = 3;

% Data Types Definitions: 
sort 	
	LightColorState = struct Green | Orange | Red;
	WeatherCondition = struct Dry | Snowing | Raining;

% User management
sort
	Users = List(Nat);
map
	setUsers': Users # Nat # Nat # Nat -> Users;
	nudgeUsers': Users # Nat # Nat # Int -> Users;

	% Mappings
	setUsers: Users # Nat # Nat -> Users;
	incUsers: Users # Nat -> Users;
	decUsers: Users # Nat -> Users;
	defaultUsers: Users;
var
	l: Users;
	i: Nat;
	t: Nat;
	c: Nat;
	b: Int;
eqn
	setUsers'([], i, t, c) = [];
	i == t -> setUsers'(l, i, t, c) = c |> setUsers'(tail(l), i + 1, t, c);
	i != t -> setUsers'(l, i, t, c) = head(l) |> setUsers'(tail(l), i + 1, t, c);
	nudgeUsers'([], i, t, b) = [];
	i == t -> nudgeUsers'(l, i, t, b) = Int2Nat(head(l) + b) |> nudgeUsers'(tail(l), i + 1, t, b);
	i != t -> nudgeUsers'(l, i, t, b) = head(l) |> nudgeUsers'(tail(l), i + 1, t, b);

	% Mappings
	setUsers(l, t, c) = setUsers'(l, 0, t, c);
	incUsers(l, t) = nudgeUsers'(l, 0, t, 1);
	decUsers(l, t) = nudgeUsers'(l, 0, t, -1);
	defaultUsers = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

% Traffic lights
sort
	TrafficLightStates = List(LightColorState);
map
	setTrafficLightState': TrafficLightStates # Nat # Nat # LightColorState -> TrafficLightStates;

	% Mappings
	setTrafficLightState: TrafficLightStates # Nat # LightColorState -> TrafficLightStates;
	defaultLights: TrafficLightStates;
var
	ts: TrafficLightStates;
	i: Nat;
	t: Nat;
	c: LightColorState;
eqn
	setTrafficLightState'([], i, t, c) = [];
	i == t -> setTrafficLightState'(ts, i, t, c) = c |> setTrafficLightState'(tail(ts), i + 1, t, c);
	i != t -> setTrafficLightState'(ts, i, t, c) = head(ts) |> setTrafficLightState'(tail(ts), i + 1, t, c);

	% Mappings
	setTrafficLightState(ts, t, c) = setTrafficLightState'(ts, 0, t, c);
	defaultLights = [Red, Red, Red, Red, Red, Red, Red, Red, Red, Red, Red, Red, Red, Red, Red, Red];

% Process: 
proc 
	LightComponent(lights: TrafficLightStates) =
		sum t: Nat. (t < TRAFFIC_LIGHT_COUNT) -> (
			(lights . t == Red) -> 
				RecvRequestGreen(t) .
				sum ree: Nat. (ree < TRAFFIC_LIGHT_COUNT) -> (
					(ree == t) -> ShowLight(ree, Green) +
					(ree != t) -> ShowLight(ree, Red)
				) .
				LightComponent(setTrafficLightState(defaultLights, t, Green))
			+
			(lights . t == Green) ->
				LightTimeout(t, Green) .
				ShowLight(t, Orange) .
				LightComponent(setTrafficLightState(lights, t, Orange))
			+
			(lights . t == Orange) ->
				LightTimeout(t, Orange) .
				ShowLight(t, Red) .
				SendCycleDone .
				LightComponent(setTrafficLightState(lights, t, Red))
		)
	;
	EVComponent(lights: TrafficLightStates) =
		sum t: Nat. (t < TRAFFIC_LIGHT_COUNT) -> ((
			EVApproaching(t) .
			EVComponent(setTrafficLightState(lights, t, Green))
		) + (
			EVPassed(t) .
			EVComponent(setTrafficLightState(lights, t, Red))
		) + (
			RecvEVPoll(t) .
			SendEVDetected(t, lights . t == Green) .
			EVComponent(lights)
		))
	;
	WeatherComponent(current: WeatherCondition) =
		sum new: WeatherCondition .
			Weather(new) .
			WeatherComponent(new)
		+
			RecvWeatherPoll .
			(
				(current == Dry) -> SendBadWeather(false) +
				(current != Dry) -> SendBadWeather(true)
			) .
			WeatherComponent(current)
	;
	UserManagerComponent(users: Users) =
		sum t: Nat. (t < TRAFFIC_LIGHT_COUNT) -> ((
			UserApproaching(t) .
			UserManagerComponent(incUsers(users, t))
		) + (
			UserPassed(t) .
			UserManagerComponent(decUsers(users, t))
		) + (
			RecvUsersPoll(t) .
			SendUsersDetected(t, users . t > 0) .
			UserManagerComponent(users)
		))
	;

	% Once a cycle is done, the order of priority is:
	% 1. EV vehicles
	% 2. Pedestrians (when raining)
	% 3. Regular cars/pedestrians
	UserDetectionComponent =
		% BUGS:
		% Doesn't properly handle priority atm
		RecvCycleDone .
		sum t: Nat. (t < TRAFFIC_LIGHT_COUNT) -> ((
			SendEVPoll(t) .
			RecvEVDetected(t, true) .
			SendRequestGreen(t)
		) + (
			SendUsersPoll(t) .
			RecvUsersDetected(t, true) .
			(
				SendWeatherPoll .
				RecvBadWeather(true) .
				SendRequestGreen(t)
			) +
			SendRequestGreen(t)
		)) .
		UserDetectionComponent
	;


% init WeatherComponent(Dry);
init
allow(
	{
		SendWeatherPoll,
		RecvWeatherPoll,
		WeatherPoll,
		SendBadWeather,
		RecvBadWeather,
		BadWeather,
		SendEVPoll,
		RecvEVPoll,
		EVPoll,
		SendEVDetected,
		RecvEVDetected,
		EVDetected,
		SendRequestGreen,
		RecvRequestGreen,
		RequestGreen,
		SendCycleDone,
		RecvCycleDone,
		CycleDone,
		SendUsersPoll,
		RecvUsersPoll,
		UsersPoll,
		SendUsersDetected,
		RecvUsersDetected,
		UsersDetected
	},
comm(	{
		SendWeatherPoll|RecvWeatherPoll -> WeatherPoll,
		SendBadWeather|RecvBadWeather -> BadWeather,

		SendEVPoll|RecvEVPoll -> EVPoll,
		SendEVDetected|RecvEVDetected -> EVDetected,

		SendRequestGreen|RecvRequestGreen -> RequestGreen,
		SendCycleDone|RecvCycleDone -> CycleDone,

		SendUsersPoll|RecvUsersPoll -> UsersPoll,
		SendUsersDetected|RecvUsersDetected -> UsersDetected
	},
UserDetectionComponent || WeatherComponent(Dry) || LightComponent(defaultLights) || EVComponent(defaultLights) || UserManagerComponent(defaultUsers)
));
