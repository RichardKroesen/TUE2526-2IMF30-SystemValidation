
% Actions Definitions: Internal
act
	% Weather polling
	SendWeatherPoll;
	RecvWeatherPoll;
	WeatherPoll;
	SendBadWeather: Bool;
	RecvBadWeather: Bool;
	BadWeather: Bool;

	% EV polling
	SendEVPoll: Nat;
	RecvEVPoll: Nat;
	EVPoll: Nat;
	SendEVDetected: Nat # Bool;
	RecvEVDetected: Nat # Bool;
	EVDetected: Nat # Bool;

	% Light timeouts
	SendRequestGreen: Nat;
	RecvRequestGreen: Nat;
	RequestGreen: Nat;
	SendCycleDone;
	RecvCycleDone;
	CycleDone;

% Actions Definitions: External 
act 
	ShowLight: Nat # LightColorState;
	LightTimeout: Nat # LightColorState;
	EVApproaching: Nat;
	EVPassed: Nat;
	Weather: WeatherCondition;
	UserApproaching: Nat;
	UserPassed: Nat;
	UsersDetected: Nat # Bool;

% Constants
map
 	TRAFFIC_LIGHT_COUNT: Nat;
eqn
	% TRAFFIC_LIGHT_COUNT = 16;
	TRAFFIC_LIGHT_COUNT = 16;

% Data Types Definitions: 
sort 	
	LightColorState = struct Green | Orange | Red;
	WeatherCondition = struct Dry | Snowing | Raining;

% User management
sort
	Users = List(Nat);
map
	setUsers': Users # Nat # Nat # Nat -> Users;
	nudgeUsers': Users # Nat # Nat # Int -> Users;

	% Mappings
	setUsers: Users # Nat # Nat -> Users;
	incUsers: Users # Nat -> Users;
	decUsers: Users # Nat -> Users;
	defaultUsers: Users;
var
	l: Users;
	i: Nat;
	t: Nat;
	c: Nat;
	b: Int;
eqn
	setUsers'([], i, t, c) = [];
	i == t -> setUsers'(l, i, t, c) = c |> setUsers'(tail(l), i + 1, t, c);
	i != t -> setUsers'(l, i, t, c) = head(l) |> setUsers'(tail(l), i + 1, t, c);
	nudgeUsers'([], i, t, b) = [];
	i == t -> nudgeUsers'(l, i, t, b) = Int2Nat(head(l) + b) |> nudgeUsers'(tail(l), i + 1, t, b);
	i != t -> nudgeUsers'(l, i, t, b) = head(l) |> nudgeUsers'(tail(l), i + 1, t, b);

	% Mappings
	setUsers(l, t, c) = setUsers'(l, 0, t, c);
	incUsers(l, t) = nudgeUsers'(l, 0, t, 1);
	decUsers(l, t) = nudgeUsers'(l, 0, t, -1);
	defaultUsers = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

% Traffic lights
sort
	TrafficLightStates = List(LightColorState);
map
	setTrafficLightState': TrafficLightStates # Nat # Nat # LightColorState -> TrafficLightStates;

	% Mappings
	setTrafficLightState: TrafficLightStates # Nat # LightColorState -> TrafficLightStates;
	defaultLights: TrafficLightStates;
var
	ts: TrafficLightStates;
	i: Nat;
	t: Nat;
	c: LightColorState;
eqn
	setTrafficLightState'([], i, t, c) = [];
	i == t -> setTrafficLightState'(ts, i, t, c) = c |> setTrafficLightState'(tail(ts), i + 1, t, c);
	i != t -> setTrafficLightState'(ts, i, t, c) = head(ts) |> setTrafficLightState'(tail(ts), i + 1, t, c);

	% Mappings
	setTrafficLightState(ts, t, c) = setTrafficLightState'(ts, 0, t, c);
	defaultLights = [Red, Red, Red, Red, Red, Red, Red, Red, Red, Red, Red, Red, Red, Red, Red, Red];

% Process: 
proc 
	LightComponent(lights: TrafficLightStates) =
		sum t: Nat. (t < TRAFFIC_LIGHT_COUNT) -> (
			(lights . t == Red) -> 
				RecvRequestGreen(t) .
				sum ree: Nat. (ree < TRAFFIC_LIGHT_COUNT) -> (
					(ree == t) -> ShowLight(ree, Green) +
					(ree != t) -> ShowLight(ree, Red)
				) .
				LightComponent(setTrafficLightState(defaultLights, t, Green))
			+
			(lights . t == Green) ->
				LightTimeout(t, Green) .
				ShowLight(t, Orange) .
				LightComponent(setTrafficLightState(lights, t, Orange))
			+
			(lights . t == Orange) ->
				LightTimeout(t, Orange) .
				ShowLight(t, Red) .
				SendCycleDone .
				LightComponent(setTrafficLightState(lights, t, Red))
		)
	;
	EVComponent(lights: TrafficLightStates) =
		sum t: Nat. (t < TRAFFIC_LIGHT_COUNT) -> ((
			EVApproaching(t) .
			EVComponent(setTrafficLightState(lights, t, Green))
		) + (
			EVPassed(t) .
			EVComponent(setTrafficLightState(lights, t, Red))
		) + (
			RecvEVPoll(t) .
			SendEVDetected(t, lights . t == Green) .
			EVComponent(lights)
		))
	;
	WeatherComponent(current: WeatherCondition) =
		sum new: WeatherCondition .
			Weather(new) .
			WeatherComponent(new)
		+
			RecvWeatherPoll .
			(
				(current == Dry) -> SendBadWeather(false) +
				(current != Dry) -> SendBadWeather(true)
			) .
			WeatherComponent(current)
	;

	RestartCycle =
		RecvCycleDone .
		EVChecking(0)
	;

	EVChecking(t: Nat) =
		(t == TRAFFIC_LIGHT_COUNT) ->
			%BadWeatherChecking(0, exclude) <>
			RestartCycle <>
			SendEVPoll(t) .
			((
				RecvEVDetected(t, true) .
				SendRequestGreen(t) .
				% BadWeatherChecking(0)
				% Once we give someone a green light, restart the cycle
				RestartCycle
			) + (
				RecvEVDetected(t, false) .
				EVChecking(t + 1)
			))
	;
	
	BadWeatherChecking(t: Nat) =
		(t == TRAFFIC_LIGHT_COUNT) ->
			RegularChecking(0) <>
			((
				UsersDetected(t, true) .
				SendWeatherPoll .
				RecvBadWeather(true) .
				SendRequestGreen(t) .
				% Once we give someone a green light, restart the cycle
				RestartCycle
			) + (
				UsersDetected(t, false) .
				BadWeatherChecking(t + 1)
			))
	;

	RegularChecking(t: Nat) =
		((t == TRAFFIC_LIGHT_COUNT) ->
			RestartCycle <>
			((
				UsersDetected(t, true) .
				SendRequestGreen(t) .
				RestartCycle
			) + (
				UsersDetected(t, false) .
				RegularChecking(t + 1)
			))
		)
	;

% init WeatherComponent(Dry);
init
hide(
	{
		SendWeatherPoll,
		RecvWeatherPoll,
		WeatherPoll,
		SendBadWeather,
		RecvBadWeather,
		BadWeather,
		SendEVPoll,
		RecvEVPoll,
		EVPoll,
		SendEVDetected,
		RecvEVDetected,
		EVDetected,
		SendRequestGreen,
		RecvRequestGreen,
		RequestGreen,
		SendCycleDone,
		RecvCycleDone,
		CycleDone
	},
allow(
	{
		SendWeatherPoll,
		RecvWeatherPoll,
		WeatherPoll,
		SendBadWeather,
		RecvBadWeather,
		BadWeather,
		SendEVPoll,
		RecvEVPoll,
		EVPoll,
		SendEVDetected,
		RecvEVDetected,
		EVDetected,
		SendRequestGreen,
		RecvRequestGreen,
		RequestGreen,
		SendCycleDone,
		RecvCycleDone,
		CycleDone,
		UsersDetected
	},
comm(	{
		SendWeatherPoll|RecvWeatherPoll -> WeatherPoll,
		SendBadWeather|RecvBadWeather -> BadWeather,

		SendEVPoll|RecvEVPoll -> EVPoll,
		SendEVDetected|RecvEVDetected -> EVDetected,

		SendRequestGreen|RecvRequestGreen -> RequestGreen,
		SendCycleDone|RecvCycleDone -> CycleDone
	},
EVChecking(0) || WeatherComponent(Dry) || LightComponent(defaultLights) || EVComponent(defaultLights)
)));
%));
